# -*- coding: utf-8 -*-
"""Занятие 2.  Функции и работа с текстами

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eAvIM0OIS4KjaoLMekmQyBn6KKqp923e

# **Работа с текстами**

---
"""


##  ***Операции над строками***

---

#### Конкатенация
"""

a = 'По'
b = 'беда'
print(a + b)

"""#### Длина строки"""

A = 'Самосвал '


print(len(A))
print(len(a))

"""#### Дублирование или повторение"""

A*8

"""#### Индексация"""

a = 'теплоход'
a

a[:5]

a[-1]

a[::-1]

"""##### Срезы"""



"""## ***Методы строк***

---

> **Метод** - функция связанная с обьектом

#### **upper()**   *`верхний регистр`*
"""

a = 'камаз'
a.upper()

"""#### **lower()**  *`нижний регистр`*"""

a = 'КаМаЗ'
a.lower()

"""#### **capitalize()** *`c заглавной буквы`*"""

a = 'добро пожаловать на курс GPT Professional'
a.capitalize()

"""#### **startswith()** *`начинается ли строка с нужного символа`*"""

a = 'Раннее утро'
a.startswith('Ран')

a.startswith('Пан')

"""#### **endswith()** *`заканчивается ли строка на нужный символ`*"""

a = 'Раннее утро'
a.endswith('тро')

"""#### **replace()** *`замена`*"""

a = 'Завтра рабочий день'
a.replace('рабочий', 'выходной')

"""#### **split()** *`Разбиение`*"""

a = 'Завтра рабочий день'
a.split()

"""#### **join()** *`Соединение`*"""

a = ['Завтра', 'рабочий', 'день']
b = ' '.join(a)
b

"""#### **strip()**



"""

a = '   завтра снова на работу         '.strip()
b = 'мне '
b + a

a = '   завтра снова на работу     '.lstrip() # Удалим пробелы слева
a

a = '   завтра снова на работу     '.rstrip() # Удалим пробелы справа
a

"""#### **count()** *`подсчёт`*"""

a = 'камаз'
a.count('а')

"""#### **find(str, [start : end])** *`поиск индекса`*
-1 (не нашёл)
"""

a = 'абракадабра'
a.find('а')

a.find('а', 2) # ищем со второго индекса

a.find('а', 8, 10) # поик с диапазоне от 5 до 6 индекса

"""#### **index(str, [start : end])** *`поиск индекса`*"""

a = 'абракдбра'
a.index('а')

a.index('а', 2) # ищем со второго индекса

a.index('а', 5, 6) # поик с диапазоне от 5 до 6 индекса

"""#### **isalnum()** *`Проверяем строку на буквы и цифры`*"""

a = '123'
b = 'абв123 '
c = 'абв? _'
print(a.isalnum())
print(b.isalnum())
print(c.isalnum())

"""#### **isalpha()** *`Проверяем строку на буквы`*"""

a = '123'
b = 'абв'
c = 'абв? _'
print(a.isalpha())
print(b.isalpha())
print(c.isalpha())

"""#### **isdigit()** *`Проверяем строку на цифры`*"""

a = '123'
b = 'абв'
c = 'абв? _'
print(a.isdigit())
print(b.isdigit())
print(c.isdigit())

"""#### **title()** *`каждое слово в верхнем регистре`*"""

a = 'какой чудесный день'
a.title()

"""#### **center(width, fillchar)** *`ширина + чем заполнить`*"""

'm'.center(3, '_')

'кот'.center(4, '_')

'm'.center(12, '_')

"""#### **ljust() + rjust()**"""

a = '1287'
a.ljust(8, '*')

a = '1287'
a.rjust(8, '*')

"""## ***Форматирование строк***

---

#### Форматирование строк

Некоторые из наиболее часто используемых специальных символов для подстановки значений при форматировании строк с использованием оператора `%`:

1. `%s`: Используется для подстановки строковых значений.

2. `%d`: Используется для подстановки целочисленных значений.

3. `%f`: Используется для подстановки значений с плавающей точкой (числа с десятичной точкой).

4. `%x` или `%X`: Используется для подстановки целых чисел в шестнадцатеричной системе счисления (буквы могут быть как нижнего, так и верхнего регистра).

5. `%o`: Используется для подстановки целых чисел в восьмеричной системе счисления.

6. `%c`: Используется для подстановки символа, соответствующего заданному числовому коду.

7. `%%`: Используется для подстановки символа `%` (экранирование `%`).

8. `%s`, `%d`, `%f`, и другие можно комбинировать с модификаторами ширины и точности для более точного форматирования.

Примеры использования:

```python
name = "Анна" # переменная типа str
age = 25 # переменная типа int
height = 1.65 # переменная типа float
print("Привет, меня зовут %s, мне %d лет и я ростом %.2f метра." % (name, age, height))
```
"""

name = "Анна" # переменная типа str
age = 25 # переменная типа int
height = 1.65 # переменная типа float
print("Привет, меня зовут %s, мне %d лет и я ростом %.1f метра." % (name, age, height))

a = 2
b = 'машины'
"%d %s" % (a, b)

"""#### Метод **format**"""

name = "Анна" # переменная типа str
age = 25 # переменная типа int
height = 1.65 # переменная типа float
print("Привет, меня зовут {}, мне {} лет и я ростом {:.2f} метра.".format(name, age, height))

data = {"name": "Иван", "age": 30, 'height':1.84}
message = "Привет, меня зовут {name} и мне {age} лет, рост {height}".format(**data)
print(message)

"""

---


> Отступ от края `{:<10} right / {:>10} left`


---

"""

animal_dict = {
    "собака": "домашнее",
    "тигр": "дикое",
    "волк": "дикое",
    "кошка": "домашнее",
    "корова": "домашнее",
    "лев": "дикое"}
animal_dict

for k, v in animal_dict.items():
  print('| {} | {} |'.format(k.ljust(10), v.ljust(10)))

for k, v in animal_dict.items():
  print('|{:<17} | {:<2}|'.format(k, v))

a = 2
b = 'машины'
'{} {}'.format(a,b)

"""

---


> центр `{:^10}`


---

"""

'{:^10}'.format('GPT')

for i in animal_dict.keys():
  print('| {:^7} |'.format(i))

"""#### f-строка"""

name = "Анна" # переменная типа str
age = 25 # переменная типа int
height = 1.65 # переменная типа float
print(f"Привет, меня зовут {name}, мне {age} лет и я ростом {height:.1f} метра.")

a = 2
b = 'машины'
f'{a} {b}'

"""# **Функции**

---

### ***Встроенные функции***

---

#### **Основные:**
* **sum()** - *`подсчет суммы`*
* **len()** - *`длина`*
* **min()** - *`минимальное значение`*
* **max()** - *`максимальное значение`*
"""

lst = list(range(10, 90, 7))
print('Список:', lst, end='\n\n')

print('Сумма:', sum(lst))
print('Длина:', len(lst))
print('Минимум:', min(lst))
print('Максимум:', max(lst))

"""#### ***Пользовательские функции***

---
Базовый вариант:

    def имя_функции():
        тело функции

Более общий вариант:

    def имя_функции(входящие параметры):
        тело функции

        return данные

"""

def greet(name): # "name" - параметр функции, некая переменная
    print(f"Привет, {name}!")

greet("Николай")  # "Николай" - аргумент, переданный в функцию

def add(a, b): # a и b - параметры функции, которые определяют, какие аргументы функция может принимать.
    return a + b # возвращает сумму аргументов

print(add(3, 2)) # вызывает функцию с позиционными аргументами 2 и 3
print(add(5, 7)) # вызывает функцию с позиционными аргументами 5 и 7

"""> Именованные аргументы"""

def add(a=10, b=2): # a и b - параметры функции, которые определяют, какие аргументы функция может принимать.
    return a + b # возвращает сумму аргументов

print(add(2, 3))
print(add())
print(add(b=20))

help(print)

print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

     По умолчанию печатает значения в поток или в sys.stdout.
     Необязательные аргументы ключевого слова:
    'file:' файлоподобный объект (поток); по умолчанию используется текущий sys.stdout.
    'sep:' строка, вставленная между значениями, по умолчанию — пробел.
    'end:' строка, добавляемая после последнего значения, по умолчанию — новая строка.
    'flush:' нужно ли принудительно сбрасывать поток

print(10, 20, sep='+')

"""#### ***lambda функция***

---
**Lambda-функция (или анонимная функция)** - это способ создания простых функций в Python без необходимости использования стандартного синтаксиса определения функции с помощью ключевого слова def. Lambda-функции могут использоваться там, где требуется передать короткое выражение, выполняющее какую-либо операцию.

\
Основные особенности:

* Анонимность: Lambda-функции не требуют имени. Они могут быть определены в точке использования.
* Однострочность: Они ограничены одним выражением и не имеют блока кода.
* Обычно используются для простых операций: Обычно lambda-функции используются для выполнения простых операций, таких как преобразование данных или фильтрация.

Синтаксис lambda-функции:

```python
lambda arguments: expression
```

Где:
- `arguments` - это список параметров (аргументов) функции.
- `expression` - это выражение, которое выполняется и возвращается как результат работы lambda-функции.

Примеры:
"""

def square2(a, b):
  return a + b

square2(4, 6)

# Lambda-функция для вычисления квадрата числа
square = lambda a, b: a + b

square(4,6)

"""#### ***sorted()*** - *`сортировка`*"""

lst = [16, 25, 19, 23, 10, 14, 15, 10, 22, 14]

# Сортировка по возрастанию (по умолчанию reverse=False)
print(sorted(lst))

# Сортировка по убыванию
sorted(lst, reverse=True)

"""#### **zip()** *`объединяет элементы из нескольких списков в кортежи. `*

---
Синтаксис:
```python
zip(iterable1, iterable2, ...)
```


"""

names = ["Alice", "Bob", "Charlie"]
age = [45, 65, 74]
scores = [85, 92]

zipped = zip(names, age, scores)
list(zipped)  # Преобразование итератора в список кортежей

list(zip(names, age, scores))

"""#### **map()** - *`применяет заданную функцию к каждому элементу последовательности`*

---



Синтаксис: `map(function, iterable)`

- `function`: Функция, которая будет применена к каждому элементу.
- `iterable`: Последовательность (например, список), элементы которой будут передаваться в функцию.

---



Пример:

"""

# Функция для вычисления квадрата числа
def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]

list(map(square, numbers))

list(map(lambda x: x**2, numbers))

"""#### **filter()** - *`фильтрует элементы последовательности`*
---
Синтаксис: filter(function, iterable)

function: Функция-предикат, которая оценивает каждый элемент и возвращает True или False.
iterable: Последовательность (например, список), элементы которой будут проверяться с помощью функции-предиката.

\
Синтаксис:
```python
filter(function, iterable)
```
* **function:** Функция, которая оценивает каждый элемент и возвращает True или False.
* **iterable:** Последовательность (например, список), элементы которой будут проверяться с помощью функции-предиката.
"""

def is_even(x):
    return x % 2 == 0

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


list(filter(is_even, numbers))

list(map(is_even, numbers))

"""## Генератор

Генератор (или generator) в Python - это специальный тип объекта, который позволяет создавать итерируемые последовательности элементов без необходимости хранить их полностью в памяти. Генераторы очень полезны при работе с большими объемами данных или при создании бесконечных последовательностей.

Генераторы определяются с использованием функций и ключевого слова yield. Когда функция с ключевым словом yield вызывается, она не выполняется полностью, а возвращает генераторный объект. При каждом вызове метода __next__() (или просто next() в Python 3) для генератора выполнение функции начинается с того места, где было использовано yield, и выполняется до следующего yield. Это позволяет поочередно генерировать значения по мере необходимости, экономя память.
"""

lst = list(range(1,6))
lst

def f1():
  a = []
  for i in range(1,6):
    a.append(i)

  return a

lst2 = f1()
lst2

def gen():
  for i in range(1,6):
    yield i

g = gen()
g

next(g)

print(next(g))

print(next(g))
print(next(g))
print(next(g))
print(next(g))

for i in g:
  print(i)

"""#### Выражение генератор"""

def gen():
  for i in range(1,6):
    yield i

g = gen()
g



g1 = (i for i in range(1,6))
g1

next(g1)

for i in g1:
  print(i)

"""#### Генератор списка


---

"""

lst = []

for i in range(10):
  lst.append(i)

lst

lst = [i for i in range(10)]
lst





g1 = (i for i in range(1,6))
lst = list(g1)
lst

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# lst = [i for i in range(300_000)]

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# lst = []
# for i in range(300_000):
#   lst.append(i)

















"""#### Отличие генератора от списка"""

b = [i*5 for i in range(400_000)]
print(b)

b = (i*5 for i in range(400_000))
print(next(b))

"""#### ==== Время ===="""

from random import randint as rd
from sys import getsizeof

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# a = [rd(1,100) for i in range(300_000)]

"""143 мс ± 645 мкс на цикл (среднее значение ± стандартное отклонение для 7 запусков, по 10 циклов в каждом)"""

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# b = (rd(1,100) for i in range(300_000))

"""---


**List** = 360 ms \
**Generator** = 0.00000036 ms (3.6e-7)


---

#### ==== Размер ====
"""

LIST = [rd(1,100) for i in range(300_000)]
GEN = (rd(1,100) for i in range(300_000))

print(getsizeof(LIST), 'byte')
print(getsizeof(GEN), 'byte')

for i in range(2):
  for n in range(5):
    print(i,n)

"""#### Генератор-списка => с вложенным списком

---

"""

ex1 = []
for i in range(10):
  for n in range(2):
    ex1.append(n)

ex1

ex2 = [n for i in range(10) for n in range(2)]
ex2



"""#### Генератор-списка => с одним условием

---
"""

ex3 = []
for i in range(10):
    if i > 5:
      ex3.append(i)

ex3

ex3 = [i for i in range(10) if i > 5]
ex3

"""#### Генератор-списка => больше одного условия

---

"""

ex4 = []
for i in range(10):
  if i%2 == 0 and i > 4:
      ex4.append(i)
  else:
      ex4.append('test')

print(ex4)

ex4 = [i if i%2 == 0 and i > 4 else 'test' for i in range(10)]
ex4

"""#### Генератор словаря

---


"""

a = {i:i+100 for i in range(10)}
print(a)

# Commented out IPython magic to ensure Python compatibility.
# %who

"""# **Модули и библиотеки**

---


Модуль (**module**) – это файл, который содержит набор связанных между собой функций, классов, переменных. Формально это любой файл с исходным кодом, имеющий расширение **.py**. В отличие от программ, модули обычно создаются для импортирования в другие программы или модули. Они не предназначены для непосредственного запуска, хотя и здесь есть варианты. Но об этом позже.

Модули упрощают написание кода: помогают упорядочить информацию, избежать повторов и нагромождений, скрыть часть кода. А также дают возможность пользоваться кодом других разработчиков.

Функции можно рассматривать как маленькие подпрограммы, которые выполняют  вычисления, преобразования, и могут многократно вызываться.

Такие функции могут не просто существовать сами по себе, но и объединяться в модули. Как правило, функции в пределах одного модуля объединены какой-то единой тематикой.

**Библиотека** же включает в себя модули различных тематик, которые содержат множество инструментов для самых разных задач. Краткая сводка:

1. Модуль — сборник классов, функций для определенных задач.

2. Библиотеки — набор модулей для определенных задач.

3. Некоторые модули нужно скачивать, некоторые уже встроены в Python.

**Стандартная библиотека Python**

Популярные модули:
- `re` — для работы с регулярными выражениями (строка, задающая шаблон поиска подстрок в тексте). Обработка текста по паттернам (шаблонам);
- `os` — для работы с операционной системой;
- `random` — для генерации случайных чисел и данных;
- `math` — для математических вычислений.

**Сторонние библиотеки для Python**

Сторонние библиотеки создают разные разработчики. Благодаря этому существует множество библиотек под разные задачи.

Обычно их нужно дополнительно устанавливать. Но Google Colab удобен тем, что уже содержит в себе множество таких библиотек. Так что только в специфических случаях придется заниматься их установкой и настройкой.

Примеры библиотек:

- Numpy нужен для работы с большими векторами, матрицами;
- Pandas отлично манипулирует таблицами данных, предназначен для обработки и анализа данных;
- Matplotlib — для визуализации и графического представления данных;
- Keras — для работы с нейросетями.

**Подключение (импорт) и использование библиотек/модулей**

Для работы с модулем его нужно сначала импортировать. Чтобы это сделать, используют инструкцию `import`:
"""

import re
import os
import math

"""Библиотеки импортируют в начале кода программы (то есть в начале ноутбука). Для настройки импорта используют инструкции `from` и `as`.

`from` позволяет импортировать не весь модуль, а конкретный объект из модуля. Например, в модуле `math` есть объект `pi`. Это переменная, содержащая число Пи. Чтобы импортировать только `pi` без `math`, нужно написать следующий код:
"""

from math import pi

"""То есть указываете, откуда вы импортируете объект, потом импортируете сам объект. Все в одной строке.

Часто объекты лежат глубже. Например, функция, которую часто в будущем придется использовать — это `tensorflow.keras.losses.MSE`. Чтобы каждый раз не писать `tensorflow.keras.losses.MSE`, можно просто загрузить ее:
"""

from tensorflow.keras.losses import MSE

"""Теперь ее можно использовать без непосредственного обращения к библиотеке `tensorflow`:"""

MSE

"""Инструкция `as` позволяет переименовать импортируемый модуль/объект:"""

import numpy as np

"""Теперь вместо, например, `numpy.array`, можно писать `np.array`:"""

np.array([])

"""Так короче, а значит — удобнее.

Конечно, можно использовать вместе все три инструкции `from`, `import` и `as`:
"""

from matplotlib import pyplot as plt

"""## 2.1 Встроенные модули **Python**

Библиотека стандартных модулей в Python весьма обширна: к вашим услугам инструменты для работы с текстами, массивами данных, таблицами, изображениями и так далее.

### Модуль `re`

**Регулярное выражение** — это строка, задающая шаблон поиска подстрок в тексте.

Функции для работы с регулярными выражениями размещены в модуле `re`.

**Основные функции модуля:**

`re.search(pattern, string)` - ищет `pattern` по всей строке `string`.

Если находит совпадение, возвращает Match-объект с первым совпадением, остальные не находит. Если не находит совпадение возвращает `None`.
"""

import re

text = 'карл у клары украл кораллы, клара у карла украла кларнет'

# поиск паттерна 'карл'
result = re.search('рл', text)
print(result)

"""`re.match(pattern, string)` - ищет `pattern` в начале строки `string`.

Если находит совпадение, возвращает Match-объект, если не находит совпадение возвращает `None`.
"""

sentence = "кабан упал и лапу на бок"

# пробуем найти 'ку'
res = re.match(r'абан', sentence)
print(res)

# пробуем найти 'ка'
res = re.match(r'ка', sentence)
print(res)

"""Чтобы вывести содержимое, найденной строки используем метод `group()`"""

print(res.group())

"""Можно использовать методы `start()` и `end()` для того, чтобы узнать начальную и конечную позицию найденной строки."""

print(res.start(), res.end())

"""`re.findall(pattern, string)` - ищет `pattern` по всей строке `string`.

Возвращает список со всеми найденными совпадениями (не Match-объект).
"""

text = 'карл у клары украл кораллы, клара у карла украла кларнет'

# поиск всех слов с заглавной первой буквой
result = re.findall('клар', text)
print(result)

"""`re.split(pattern, string, [maxsplit=0])` - разделяет строку `string` по подстрокам, соответствующим `pattern`."""

# разделим строку на подстроки
result = re.split(r', ', text)
print(result)

"""`re.sub(pattern, repl, string)` - заменяет в строке `string` все `pattern` на `repl`."""

text = 'Карл у Клары украл кораллы, Клара у Карла украла кларнет'

# поиск паттерна с заменой
result = re.sub('Карл', 'Джон', text)
print(result)

"""|Символ|Значение|
|------|--------|
|`\d`|Любая цифра. То же самое, что `[0-9]`|
|`\D`|Любой символ, кроме цифры. То же самое, что `[^0-9]`|
|`\w`|Любая буква, цифра и нижнее подчёркивание|
|`\W`|Любой символ, кроме буквы, цифры и нижнего подчёркивания|
|`\s`|Любой пробельный символ (пробел, новая строка, табуляция)|
|`\S`|Любой символ, кроме пробельного|
|`\A`|Начало строки. То же самое, что `^`|
|`\Z`|Конец строки. То же самое, что `$`|
|`\b`|Начало или конец слова|
|`\B`|Середина слова|
|`\n`, `\t`, `\r`|Стандартные строковые обозначения: новая строка, табуляция, возврат каретки|

"""

# пример использования "\d"
text = 'Если арабские числа 20 и 56 перевести в римские, то получится XX и LVI'

# поиск по паттерну "\d"
result = re.findall(r'\d', text)
print(result)

# пример использования "\D"
text = 'Если арабские числа 20 и 56 перевести в римские, то получится XX и LVI'

# поиск по паттерну "\D"
result = re.findall(r'\D', text)
print(result)

# пример использования "+"
text = 'Какое число самое большое: 5, 45, 235, 78, 99?'

# поиск по паттерну "\b\d+\b"
result = re.findall(r'\b\d+\b', text)
print(result)

"""Подробнее https://colab.research.google.com/drive/10gyViE3w6pi6GA84roqoULjPllYE-KkK?usp=sharing

### Модуль `os`

Он предоставляет множество инструментов для работы с файлами (открыть, записать, прочитать, закрыть и т.д.):
"""

import os
import shutil
from zipfile import ZipFile

"""<h3>Работа с файловой системой</h3>

Получение списка файлов и папок выбранной директории
"""

# получим список всех вложенных файлов в директории /content/sample_data
os.listdir('/etc')

"""Смена рабочей директории

"""

# показать текущий каталог (рабочую директорию)
os.getcwd('/bin')

os.listdir() # получим список всех вложенных файлов в директории

os.chdir('..') # изменяет текущую директорию на родительскую директорию

import sys
sys.path[0] # возвращает путь к текущей директории

sys.path.append('/content/MyModule') # Добавить свой путь для загрузки модуля.

# меняем рабочую директорию

os.chdir('/sys') # сменить директорию на абсолютный путь
os.getcwd() # возвращает текущую директорию

os.chdir('/content') # сменить директорию на абсолютный путь
os.getcwd()

os.chdir('sample_data') # сменить директорию на подпапку
os.getcwd()

"""Проверка существования файлов или папок (...пути)




"""

# в случае существования файла README.md функция вернёт True
os.path.exists('/content/sample_data/README.md')

# в случае существования файла WRITEME.md функция вернёт True
os.path.exists('/content/sample_data/WRITEME.md')

os.chdir('/content') # сменить директорию на подпапку
os.getcwd() # возвращает текущую директорию

os.path.exists('/content/sample_data')



"""Создание папок

"""

# создадим папку folder_1 в директории /content/sample_data
os.mkdir('/content/sample_data/folder_1')

# Commented out IPython magic to ensure Python compatibility.
# %%html
#
# <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
# <html>
#  <head>
#   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
#   <title>Пример веб-страницы</title>
#  </head>
#  <body>
#   <h1>Заголовок</h1>
#   <!-- Комментарий -->
#   <p>Первый абзац.</p>
#   <p>Второй абзац.</p>
#  </body>
# </html>

# Commented out IPython magic to ensure Python compatibility.
# %lsmagic

"""Переименование файлов и папок

"""

# переименуем папку folder_1 в documents_1
os.rename('/content/sample_data/folder_1',    # путь к папке со старым именем
          '/content/sample_data/documents_1') # путь к папке с новым именем

# переименуем файл mnist_tect.csv в pandas_df.csv
os.rename('/content/sample_data/mnist_test.csv', '/content/sample_data/pandas_df.csv')

"""Удаление файлов и папок"""

# удалим файл pandas_df.csv из директории /content/sample_data
os.remove('/content/sample_data/pandas_df.csv')

# удалим папку documents_1 из директории /content/sample_data
os.rmdir('/content/sample_data/documents_1')

"""Перемещение файлов и папок

Создадим 5 папок в директории `\content\sample_data` и переместим 4 из них в оставшуюся.
"""

# создадим папку, в которую переместим другие папки
os.mkdir('/content/sample_data/main')

# создадим ещё 4 папки в той же директории
for i in range(1,5):
  os.mkdir(f'/content/sample_data/folder_{i}')

import shutil

# переместим папку folder_1 в папку main

shutil.move('/content/sample_data/folder_1', '/content/sample_data/main/folder_1')

# переместим файл mnist_train_small.csv в папку main
shutil.move('/content/sample_data/mnist_train_small.csv', '/content/sample_data/main/mnist_train_small.csv')

"""Копирование файлов и папок

Скопируем файл `mnist_train_small.csv` из директории `\content\sample_data\main` в директорию `\content\sample_data`
"""

# cкопируем файл в его изначальную директорию
shutil.copy('/content/sample_data/main/mnist_train_small.csv', '/content/sample_data/mnist_train_small.csv')

"""Чтобы скопировать папку со всем содержимым, воспользуемся функцией `shutil.copytree()`"""

shutil.copytree('/content/sample_data', '/content/new')

"""Архивирование/разархивирование данных"""

# Архивируем файл my_file.txt
with ZipFile("MyZip.zip", "w") as myzip:
    myzip.write("/content/sample_data/main")

# Разархивируем созданный zip файл в новую папку
with ZipFile("MyZip.zip", "r") as myzip:
    myzip.extractall(path='new_folder/', # путь, куда извлечь файлы
                     members=None,       # список названий файлов, которые нужно извлечь из архива
                     pwd=None)           # пароль, если архив таковой имеет

"""## **2.2 Самостоятельно написанные модули**

Кроме всего прочего, самостоятельно разработанные модули позволяют собрать в одном месте все функции, а затем удобно ими пользоваться в нескольких проектах. Шаги, которые вам предстоит выполнить для создания своего собственного модуля:
1. Написание кода, который будет помещен в модуль **имя_файла.py**:
"""

# Код, который будет сохранен в файл

'''
  1) Вывод на экран: Функция проверки количества символов во фразе
  2) Объявление функции
  3) Вывод на экран: Completed

'''

"""2. Проверка и доработка кода, который будет помещен в модуль **имя_файла.py**;
3. Сохранение кода модуля в файле с помощью переменной **text**:
"""

text = '''
import os
os.mkdir('Example')

for i in range(1,6):
    with open(f'Example/file_{i}.txt', 'a') as f:
        f.write(f'Fail № {i}')
'''.strip()


print(text)

"""Обычно для записи значений строк используются два вида кавычек, например `'текст'` или `"текст"`.

В данном примере использован строковый литерал для многострочного комментария `'''текст'''`. Тройные кавычки позволяют сохранять в переменной текст со всеми переносами строк. В то же время с ним можно работать и как с обычным текстом в **Python**.

Так как в переменной **text** содержится строка, вам доступны строковые методы, такие как `.upper()`, `.lower()`, `.split()` и пр. В данном случае используйте метод `.strip()`. Он удалит ненужные символы перевода строки в начале и конце текста:
"""

# Открытие файла или создание, если такового нет

with open('my_module.py',    # название открываемого/создаваемого файла
          'w'            # режим работы с файлом, "w" - write (перезапись), "r" - read (чтение)
          ) as f:

    f.write(text)  # запись переменной в файл

# Commented out IPython magic to ensure Python compatibility.
# %run my_module.py

"""**Важно!** Перезапись влечет за собой удаление содержимого файла, если файл уже существовал на момент вызова. Чтение никак не изменяет файл, просто дает доступ к его содержимому.

После выполнения кода должен появиться файл **my_module.py** в дереве файлов в левой части ноутбука

Ключевое слово **with** перед вызовом функции `open()` запускает ***контекстный менеджер***, который по завершении кода внутри **with** автоматически закроет файл. Можно записать все необходимые действия и явно:
"""

f = open('my_module.py', 'w')
f.write(text.strip())
f.close()

"""**Важно!** Закрывать файл после работы - хорошая практика программирования. Она избавляет от многих ошибок и проблем с памятью.

### Запуск модуля с помощью интерпретатора **Python**

На данный момент вы создали файл и поместили в него текст из переменной (код на языке **Python**). Протестируйте созданный модуль, запустив его из командной строки с помощью интерпретатора **Python**:
"""

# Commented out IPython magic to ensure Python compatibility.
# %run my_module.py

# Запуск модуля из командной строки (начинается с !)

!python my_module.py

"""Интерпретатор выполнил весь код, записанный в вашем программном файле (модуле) - поэтому вы и увидели такие строки. По сути это аналогично запуску ячейки Colab с кодом из модуля:

"""

print('Функция проверки количества символов во фразе')

def check_text(text="Привет, Мир!", ot=10, do=17):

    length = len(text)

    if length > ot and length < do:
        itog = "Количество символов во фразе в пределах заданного диапазона"
    else:
        itog = "Количество символов во фразе выходит за пределы заданного диапазона"
    return itog

print('Completed!')

"""Пока функция `check_text()` никак себя не проявила, потому что к ней не было обращения, и она не запрограммирована на автоматический запуск при старте модуля. Чтобы ею воспользоваться, импортируйте весь модуль целиком в ноутбук с помощью инструкции **import**:





"""

import my_module

"""Теперь вам доступны все переменные и функции, которые есть в модуле **my_module**:"""

# Вызов функции check_text из импортированного модуля my_module

my_module.check_text("Привет, Мир!", 10, 17)  # аргументы можно задать свои, а можно пропустить, оставляя значение по умолчанию

"""Вы уже знаете, что, в отличие от программ, модули не предназначены для непосредственного запуска, и обычно их создают для подключения к другим программам.

Посмотрим, как это можно изменить.

Определим условие вывода строки `print('Completed!')` через условную конструкцию

```
if __name__ == '__main__':
```

что буквально означает следующее: если значение служебной переменной `__name__` равно `'__main__'`, то нужно выполнить код из блока условного оператора.

Вы проверяете именно это условие, потому что только при запуске с помощью интерпретатора `!python` имя вашего модуля (значение служебной переменной `__name__`) становится `'__main__'`.

Иначе говоря, конструкцию `if __name__ == '__main__':` используют, чтобы определённый код выполнялся только в момент запуска модуля при помощи `!python`. Это может быть информация об установке модуля, его версия и прочее, что может быть необходимо только при установке, а в остальное время данная информация не нужна.

Проверьте, как это работает:
"""

# Занесение кода в виде строки в переменную text

text = '''

print('Функция проверки количества символов во фразе')

def check_text(text="Привет, Мир!", ot=10, do=17):

    length = len(text)

    if length > ot and length < do:
        itog = "Количество символов во фразе в пределах заданного диапазона"
    else:
        itog = "Количество символов во фразе выходит за пределы заданного диапазона"
    return itog

print(__name__)

if __name__ == '__main__':
    print('Completed!')

'''

"""Прежде чем запустить свой модуль, создайте отдельную папку в директории colab, в которой он будет храниться. Для этого вам потребуется библиотека **os**.

Создайте папку **Project** и добавьте в нее модуль **my_module_2.py** с новым вариантом кода:
"""

# Импорт библиотеки
import os

# Создание папки с помощью функции mkdir() модуля os
os.mkdir('Project')  # принимает путь в качестве аргумента

with open('Project/my_module_2.py',
          'w'
          ) as f:

    f.write(text.strip())

"""Проверьте дерево файлов в левой части ноутбука: оно должно содержать папку **Project** и файлы **my_module.py** и **my_module_2.py** по следующему образцу:


Запустите ваш модуль с помощью `!python`, указав путь к файлу модуля, включая и название содержащей его папки:
"""

!python Project/my_module_2.py

"""### Подключение модуля к ноутбуку colab

Попробуйте подключить модуль в ячейку Colab с помощью оператора **import**:
"""

# Вызовет ошибку, так как файла модуля нет в текущей папке

import my_module_2

"""Данная ошибка говорит о том, что **Python** не смог найти модуль **my_module_2**. И это логично, потому что в рабочей папке действительно нет такого файла.

Для подключения модуля придется указать полный путь к модулю в точечной нотации:
"""

import Project.my_module_2

"""После подключения модуля появилась возможность обращаться к его функциям, переменным и классам через точку:


Также имеется возможность импортировать только отдельные функции из модуля:
"""

from Project.my_module_2 import check_text

check_text("Привет, Мир!", 10, 17)

"""Передача параметров в функции модуля ничем не отличается от их передачи в обычные функции.

Посмотрим на определении функции в коде модуля:

```
check_text(text="Привет, Мир!", ot=10, do=17)
```

где **check_text** - имя функции, а **text="Привет, Мир!", ot=10, do=17** - параметры функции. Значение по умолчанию присваивается параметру, если этот параметр не передан при вызове функции. На примере это выглядит так:
"""

print('в вызове функции не заданы параметры')
print(check_text())
print('')

print('в вызове функции заданы значения параметров')
print(check_text("Привет, Мир!", 10, 17))
print('')

print('в функцию в качестве параметров переданы значения')
text = "Привет, Мир!"
ot = 10
do = 17
print(check_text(text, ot, do))