# -*- coding: utf-8 -*-
"""Базовый блок | Синтаксис Python #2 | УИИ

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z6KsFHEYA6LFS3hiILM-eFw_DaYqYUuG

**Содержание темы**

1. [Часть 1](https://colab.research.google.com/drive/1KwsknDYT-51RKcAZgCaVV-LqsjJN7xQE?usp=sharing)

2. Часть 2

# Синтаксис **Python**

Вы продолжаете знакомство с синтаксисом языка **Python**. Пройденный материал уже позволяет вам создавать небольшие программы, общаться с пользователем при помощи функций ввода (`input()`) и вывода (`print()`) информации.

Далее вы пополните свои знания дополнительными возможностями и инструментами, которые станут незаменимыми помощниками в знакомстве с нейронными сетями.

##Циклы

Перед вами стоит задача: вывести на экран числа от 1 до 50. Писать 50 раз функцию `print()` – неудобно, это займет много времени. Вам помогут **циклы**.

Циклы в языках программирования используются для повторения какого-либо действия несколько раз. Вы рассмотрите два вида циклов: `while` и `for`.

<h1> <strong> Цикл while </strong> </h1>

Цикл `while` выполняет команды внутри своего блока пока условие, заданное для этого цикла, истинно. Рассмотрим синтаксис цикла `while`:

    while логическое_условие:
        блок кода
        (повторяется, пока логическое_условие истинно)


С английского "**while**" переводится как "**пока**". То есть вы буквально говорите вашему компьютеру:

    пока логическое условие истинно
        повторяй это

Пример:
"""

# Создание переменной-счетчика для чисел от 1 до 50
counter = 1

while counter < 51:                       # Пока счетчик меньше 51
    print(counter)                        # Вывод на экран значения счетчика
    counter += 1                          # Увеличение значения счетчика на единицу

"""Здесь необходимо пояснить работу оператора: `+= 1`.

В данном случае вы увеличиваете значение переменной на единицу. Другими словами, запись:

        counter += 1   

аналогична следующей:

        counter = counter + 1   

Подобный подход можно применить для большинства арифметических операций (`-=`, `*=`, `%=` и т.п.)

Показанный выше цикл позволил вам с легкостью вывести числа от 1 до 50. И вам потребовалось для этого не 50 строк кода, а всего 4.

Однако при использовании этого цикла можно попасть в ловушку: если условие цикла всегда будет истинным, то он будет работать бесконечно. То есть ваша программа зависнет, "зациклится". Запустите ячейку ниже:
"""

counter = 0
while counter < 5:
    input("Введите число: ")

"""Такая программа будет выполнять команды внутри цикла до тех пор, пока вы ее принудительно не остановите, что и вызовет ошибку.

Чтобы принудительно остановить выполнение программы, нажмите на кнопку «Стоп» в левой части ячейки с кодом.

Исправьте код выше, чтобы программа запрашивала от пользователя число всего 5 раз. Для этого достаточно добавить всего одну строку кода.
"""

counter = 0
while counter < 5:
    input("Введите число: ")
    counter += 1

"""---
Дополнительная информация ([База знаний УИИ - «**Цикл while**»](https://colab.research.google.com/drive/1Bm246y1NjzfJxI_yrQwuwgp1CuGfi13G?usp=sharing))

---

<h1> <strong> Цикл for </strong> </h1>

Цикл вида `for` работает с **последовательностями** – наборами чисел.

Поэтому для начала научимся создавать последовательности, например, с помощью функции `range()`.


В качестве аргументов в функцию `range()` можно подать от 1 до 3 чисел. Рассмотрим все варианты:
* **range(10)** создаст последовательность от 0 до 9;
* **range(3, 12)** создаст последовательность от 3 до 11;
* **range(4, 13, 2)** создаст последовательность от 4 до 12 с шагом в 2.


Как вы заметили, первое число всегда включается в последовательность, а последнее – нет.

Теперь рассмотрим цикл `for`.

Код в цикле такого вида выполняется столько раз, сколько объектов в последовательности.

Синтаксис выглядит следующим образом:

        for i in «последовательность»:
            тело_цикла

Если переводить это на русский, получится что-то вроде:

        для переменной i в «последовательности»

То есть вы говорите вашей программе:

<blockquote>
выполни команды в теле цикла для переменной i, которая будет поочередно принимать значения заданной последовательности.
</blockquote>
Возможно, это выглядит довольно запутанно. Разберем на конкретном примере:
"""

# Создание цикла, в котором переменная i будет поочередно
# принимать значения чисел из последовательности.
# Сама последовательность генерируется функцией range()
# Последовательность будет состоять из чисел от 0 до 4
for i in range(5):
    print(i)                              # Вывод значения i на экран

"""Как видите, все довольно просто.

* у нас есть последовательность от 0 до 4 (помните, что последнее число не включено, поэтому до 4, а не до 5);
* в первой итерации цикла переменная **i** принимает значение 0, поскольку это первое значение последовательности;
* запускается тело цикла `print(i)` и переменная выводится на экран;
* запускается следующая итерация (повтор) цикла, на этот раз значение переменной **i** равно 1, поскольку это второе значение последовательности;
* снова запускается тело цикла, теперь на экран выводится 1;
* и так далее, пока не дойдем до конца последовательности.

Теперь, экспериментируя с функцией `range()`, можно добиваться разных результатов. Рекомендуем вернуться на несколько ячеек назад и освежить в памяти эту функцию.

"""

# Вывод на экран чисел от 16 до 20:

for i in range(16, 21):
    print(i)

# Вывод чисел от 10 до 20 с шагом 2,
# то есть всех четных чисел от 10 до 20

for i in range(10, 21, 2):
    print(i)

# Вспомнив материал первой части урока,
# можно написать программу, выводящую все значения в одну строку

for i in range(10, 21, 2):
    print(i, end=' ')

"""**Факт: переменную внутри цикла `for` можно называть как угодно. Но часто ее называют именно i.**

Вы разобрались с тем, как пользоваться циклом `for`. И разобрались с тем, как создавать для него последовательности.

Но что, если вам необходима более сложная последовательность, чем «от a до b с шагом в c»? Что, если вы хотите задать последовательность самостоятельно?

В этом случае вам не обойтись без списков.

---
Дополнительная информация ([База знаний УИИ - «**Функция range()**»](https://colab.research.google.com/drive/1eWJ1enY4FdBVXsGumWZPRIgS6o1VvyDA?usp=sharing))

---

---
Дополнительная информация ([База знаний УИИ - «**Цикл for**»](https://colab.research.google.com/drive/1wSHZxtDtzrbPFlivvnoKaazEhx4NhTyc?usp=sharing))

---

##Списки

Задача следующая: сохранить в программе все числа месяца, когда шел дождь. Создавать для каждого такого дня отдельную переменную – неудобно. Поэтому воспользуемся списками.

**Список (list)** – это контейнер для всевозможных данных. Объявляются списки так же, как переменные, только значения списка заносятся в квадратные скобки:

        my_list = [1, 2, 3]
Перенесемся в ячейку кода и закрепим все на практике. Попробуем создать пустой список и выведем его на экран:
"""

empty_list = []
print(empty_list)

"""Теперь попробуем создать список с целыми числами (обратите внимание, что числа разделены запятыми):"""

first_list = [1, 2, 3, 4, 5, 3, 2, 1, 4]
print(first_list)

"""А сейчас проверим, может ли список содержать в себе значения разных типов данных:"""

second_list = [1, 2, 3.14, "Hello", True, 43, False, 'bla bla']
print(second_list)

"""Как видите, списки могут содержать в себе значения любых типов данных, которые вы изучили выше. Более того, списки могут содержать внутри себя другие списки:"""

# Создание списка, содержащего другие списки

ndim_list = [12, 23, first_list, second_list]
print(ndim_list)

"""Сделаем требуемый в задаче список с числами дней месяца, в которые шел дождь:"""

rainy_days = [1, 12, 13, 14, 16, 19, 20]
print('Дождливые дни в этом месяце:', rainy_days)

"""А теперь представим, что вы хотите вывести на экран пятый дождливый день месяца. Для этого вам нужно обратиться к списку по **индексу**.

**Индекс** – это порядковый номер элемента списка. Важно знать, что элементы в списках всегда нумеруются с **0**. То есть, чтобы вывести на экран первый дождливый день, вам нужно обратиться к элементу списка под индексом **0**:

"""

print('Первый дождливый день месяца:', rainy_days[0], 'мая')
print('Пятый дождливый день месяца:', rainy_days[4], 'мая')

"""В конце прошлого раздела мы задались вопросом: как создать цикл `for` со сложной последовательностью?

В качестве последовательности можно указать список:
"""

# Использование цикла для вывода всех дождливых дней месяца

print('Дождливые дни в этом месяце: ', end='')
for i in rainy_days:
    print(i, end=' ')

"""Если нам нужно получить не один из элементов списка, а некоторую их последовательность, можно воспользоваться **слайсингом**.

У вас есть список длиной 60000. И вы делите его на три части:
- от 0 до 48000, обозначается `[:48000]`
- от 48000 до 54000, обозначается `[48000:54000]`
- от 54000 до конца, обозначается `[54000:]`

Для работы со списками существует набор **методов**.

**Методы** – это функции, которые доступны для определенного типа объектов, например, для списков. Метод вызывают следующим образом:

        список.название_метода(аргумент)
Рассмотрим на примере:
"""

print(rainy_days)

# Метод .append(x) добавляет значение x в конец списка
rainy_days.append(24)
print(rainy_days)

# Метод .insert(i, x) вставляет на i-ое место значение x
rainy_days.insert(1, 4)
print(rainy_days)

"""**Список методов для работы со списками:**

 - **list.append(x)** добавляет значение **x** в конец списка;
 - **list.extend(list2)** расширяет список, добавляя в конец все элементы списка **list2**;
 - **list.insert(i, x)** вставляет на **i**-ое место значение **x**;
 - **list.remove(x)** удаляет первый элемент в списке, имеющий значение **x**. Если такого элемента не существует, произойдет ошибка **ValueError**;
 - **list.pop([i])** удаляет **i**-ый элемент и возвращает его. Если индекс не указан, удаляется последний элемент;
 - **list.index(x, [start [, end]])** возвращает положение (индекс) первого элемента со значением **x** (при этом поиск в списке ведется от **start** до **end**);
 - **list.count(x)** возвращает количество элементов со значением **x**;
 - **list.sort([key=функция])** сортирует список на основе функции;
 - **list.reverse()** перестраивает элементы списка в обратном порядке;
 - **list.copy()** возвращает поверхностную копию списка;
 - **list.clear()** очищает список.
"""

# Поэкспериментируйте с методами в этой ячейке

"""Если вы хотите узнать количество элементов в списке (длину списка) - воспользуйтесь встроенной функцией `len()`:"""

# Вывод на экран длины списка rainy_days
print('Длина списка rainy_days:', len(rainy_days))

"""---
Дополнительная информация ([База знаний УИИ - «**Методы работы со списками**»](https://colab.research.google.com/drive/1h0vZkvfcl_CgAJ3_sp_cVVzRhY0_-nYK?usp=sharing))

---

##Кортежи

**Кортеж (tuple)** – это тот же список, только в нем нельзя изменять значения. Кортежи занимают меньше памяти и работают быстрее, а потому рекомендуется использовать кортеж вместо списка там, где не требуется менять содержимое.

Например, чтобы хранить дни недели по порядку (понедельник, вторник, среда и т.д.) лучше использовать кортеж, так как менять дни недели не придется – их всегда 7 и они всегда следуют в одном порядке.

Однако чтобы хранить изменяемые данные, например, количество употребленных калорий за последние 7 дней, следует использовать список, так как каждый день его содержимое будет обновляться.

Кортеж объявляется точно так же, как и список, только скобки круглые.

А теперь создадим разные кортежи:
"""

# Пустой кортеж
empty_tuple = ()
print(empty_tuple)

# Кортеж целых чисел
first_tuple = (1, 2, 3, 4, 5, 3, 2, 1, 4)
print(first_tuple)

# Кортеж может содержать в себе данные
# разных типов - любых, которые изучены выше
second_tuple = (1, 2, 3.14, "Hello", True, 43, False, 'bla bla')
print(second_tuple)

# Кортеж может содержать в себе другие кортежи
ndim_tuple = (12, 23, first_tuple, second_tuple)
print(ndim_tuple)

"""Есть одна хитрость. Если вы хотите создать кортеж из одного элемента, запись должна выглядеть следующим образом:"""

# Это кортеж из одного элемента
third_tuple = (1, )
print(type(third_tuple))

# А это не кортеж, а выражение, как если бы вы написали (1 + 0)
# В данном случае Python воспринимает скобки как признак
# приоритета операции, а не как признак кортежа
wrong_tuple = (1)
print(type(wrong_tuple))

"""Попробуем изменить второй элемент списка и кортежа на 5:"""

print('Дан список:', first_list)
first_list[1] = 5
print('Список после замены элемента:', first_list)

"""Для списка все прошло без проблем - значение элемента изменилось на указанное нами.

Теперь попробуем выполнить ту же операцию для элемента кортежа:
"""

print('Дан кортеж:', first_tuple)
first_tuple[1] = 5
print('Кортеж после замены элемента:', first_tuple)

"""**Ошибка!** Как было сказано ранее - содержимое кортежа неизменяемо.

И не забывайте, что нумерация индексов всегда начинается с **0**.

---
Дополнительная информация ([База знаний УИИ - «**Методы работы с кортежами**»](https://colab.research.google.com/drive/1pAysntvUrXSs32_WYL1iqmnpcUIdVsLa?usp=sharing))

---

##Словари

**Словарь (dict)** – тип данных в **Python**, позволяющий сохранять и выбирать элементы по ключу.

Таким образом, **словарь** – это ассоциативный список.

Словарь объявляется с помощью фигурных скобок и имеет следующий синтаксис:
"""

# Создание словаря

my_dict = {'Зима': 'снег',
           'Весна': 'солнце',
           'Лето': 'фрукты',
           'Осень': 'листья'
          }

print(my_dict)

"""Первый элемент в каждой строке – это **ключ**, а второй – **значение**.

Для словарей предусмотрены **методы**. С помощью некоторых из них можно вывести только ключи, только значения, либо пару ключ-значение:

"""

# Метод .keys() возвращает набор ключей словаря
print(my_dict.keys())

# Метод .values() возвращает набор значений словаря
print(my_dict.values())

# Метод .items() возвращает набор пар ключ-значение
print(my_dict.items())

# Возможно получение значение элемента словаря, обратившись по его ключу
my_dict['Лето']

# Однако подобным образом невозможно получить ключ элемента словаря по соответствующему значению
my_dict['снег']

"""Иногда требуется удалить из словаря некоторый элемент и при этом значение удаляемого элемента записать в переменную. Это можно сделать с помощью метода `.pop()`."""

# Метод .pop() удаляет из словаря элемент с ключом "Весна",
# значение удаляемого элемента записывается в переменную element
element = my_dict.pop('Весна')

print(element)
print(my_dict)

"""Заметим, что **списки**, **кортежи** и **словари** – это тоже типы данных, которые могут содержать в себе элементы других типов, изученных ранее: `int`, `float`, `str` и `bool`, а также и другие списки, кортежи и словари.

---
Дополнительная информация ([База знаний УИИ - «**Методы работы со словарями**»](https://colab.research.google.com/drive/16jySAW85TgkxJbOgM1kM4Ej7UAbcG6w8?usp=sharing))

---

## Функции в **Python**

Мы только что разобрались, что с компьютером можно общаться на понятном ему языке, давать ему различные команды, которые он выполнит. Узнали, что он понимает и привычные нам числа, строки, может решать арифметические примеры и даже складывать целые предложения из слов. А еще он может все это разом взять и расставить по полочкам, чтобы нам было удобно, и даже названия этим полочкам дать и запомнить!

И тут вопрос:
<blockquote>
а можно ли задать компьютеру любую задачу?
</blockquote>

Например, *«Напиши-ка мне таблицу умножения»*.

Да с легкостью! Но опять же, компьютер поймёт нас только на своём языке. В нашем случае – на **Python**.

«Напиши-ка» на языке **Python** – это `print`. Затем идут скобки для задания – `print()`.

А как дальше быть? Попробуйте самый простой способ: узнайте в Google-переводчике, как по-английски будет «таблица умножения». Получите ответ – multiplication table.

Опробуйте свои новые знания:
"""

print(multiplication_table)

"""Куча всего непонятного в результате. Но зато выделяется строчка:

        NameError: name 'multiplication_table' is not defined

Подобного вида сообщения означают какую-то ошибку (**Error** – ошибка) в диалоге с компьютером.

В чем состоит ошибка? Компьютер вам говорит: «Вы мне не объяснили, что такое multiplication table!». **Not defined** переводится как «не определено».

Учитывайте, что компьютер – не интернет и даже не «Википедия». Это, скорее, очень умный помощник. Пока что разговор с ним не может быть просто обменом сообщениями на английском. Но в этом есть и плюсы: терминов, которые понимает компьютер на **Python**, в сотни раз меньше, чем слов в любом человеческом языке. Да и правил тут куда меньше.

Один из таких терминов – **define**. В **Python** слово **define**  используют в сокращенном виде – **def**. Так что достаточно написать компьютеру **def**, и он поймет, что перед ним новая инструкция.

Добро пожаловать в следующую главу **«Функции Python»**.
"""

def multiplication_table:

"""Пока не торопитесь запускать этот код, он еще сыроват!

Раз компьютер – не энциклопедия, а помощник, то ему сначала надо объяснить, что и как выполнить. Если вы правильно объясните, то и он все верно выполнит. Выше написано: def multiplication table.

Если перевести с компьютерного, то получится что-то вроде «Определяю для тебя кое-что новое: таблица умножения». Правда, тут добавился еще и знак двоеточия. Это потому, что следом пойдет объяснение, как компьютеру составить такую таблицу.

Ничего не забыли, двигаемся дальше? А как же число, для которого нужно получить таблицу умножения? Да, было бы здорово сделать ее сразу для всех чисел, но не торопитесь, всему свое время. А пока что научимся делать таблицу умножения только для одного числа:


"""

def multiplication_table(number):

"""В скобках добавилось некое **number**. Но в начале занятия уже упоминалось, что в **Python** можно придумывать свои слова, чтобы потом их повторно использовать.

Главное, чтобы они были из латинских букв. И **num**, и **multiplication table** – как раз такие слова. Еще их называют именами.
Здесь в скобках указано имя переменной **number** – переменная и будет содержать то любое число, которое вы будете умножать в будущей таблице. Пока что назовите его так, а потом подставляйте туда все, что захотите, хоть девятку, хоть квадриллион. Последнее лучше не делать, пожалейте свой компьютер.

А на что умножать? Обычно в таблице умножения умножают на числа от 1 до 9.  Но вам же нужна помощь от компьютера, не расписывая ему все действия: сначала умножь на 1, потом на 2 … и т.д.

Что делать? Задайте отсчет!

<hr><strong>
Подсказка: чтобы умножение началось с единицы, укажите предыдущее значение. Так компьютер поймет, откуда отсчитывать. А предыдущее у вас – это ноль.
</strong>
<hr>


"""

def multiplication_table(number):
    by_number = 0

"""Почему вдруг **by_number**?

Раз вы решили назвать таблицу по-английски – multiplication table, а не tablitza umnozheniya, то к чему дальше коверкать язык?  

Загляните в онлайн-переводчик. Выражение **«by number»** c английского  переводится как «на  число». Вы же умножаете одно число ***на*** другое, так что можно написать: одно число (**number**) умножить на другое число (**by_number**).

А в значении **by_number** задайте **0** – начало отсчета для второго числа в таблице умножения.

Еще немного волшебства на **Python**:

"""

def multiplication_table(number):
    by_number = 0
    while by_number <= 9:

"""И этот код еще рано запускать, но вы уже почти закончили!

Ранее уже упоминались циклы – команды на **Python**, которые заставляют компьютер повторять действия. Вы уже знаете, что **while** с английского – это «пока». Если перевести то волшебство, что вы только что добавили с **Python** на человеческий, то получится:

        while by_number <= 9 – «Повторять, пока второе число меньше или равно 9»

Команда задана, дальше просто умножайте одно число на другое.
"""

def multiplication_table(number):
    by_number = 0
    while by_number <= 9:
        by_number = by_number + 1
        result = number * by_number

"""Рассмотрим код по строкам:

* **def multiplication_table(number)** – задано имя для функции и указано, что функция должна принимать один аргумент;
* **by_number = 0** – счетчик для второго множителя (by_number), ему задано начальное значение нуль;
* **while by_number <= 9** – создан цикл while;
* **by_number = by_number + 1** – счетчик увеличен на единицу;
* **result = number * by_number** – первое число последовательно умножается на все числа счетчика. Каждый раз результат умножения сохраняется в переменную **result** (результат). Предыдущий результат теряется.

Вы только что почти написали свою функцию (а именно так эта многострочная команда для компьютера и называется).

Почти, потому что осталась пара штрихов, чтобы вывести результат на экран.

Сделайте это красиво, ведь компьютер и так подставит все числа в придуманные вами переменные. Просто скомандуйте ему `print()`, и в скобках укажите, что именно напечатать:
"""

# Определение вашей новой функции
def multiplication_table(number):
    # Далее - тело функции
    by_number = 0
    while by_number <= 9:
        by_number = by_number + 1
        result = number * by_number
        print(number, "*", by_number, "=", result, "\n")  # Команда вывода; вспомните - "\n"- символ переноса строки

"""Получилась составная инструкция для компьютера: первое число (**number**) умножить (\*) на второе число (**by_number**), произведение записать (=) в переменную-результат (**result**). Результат напечатать. Все это повторить для **by_number** от **0** до **9**.

Ну что, попробуете? Запускайте код!

Ничего не произошло.

Верно, вы ведь написали только инструкцию, обучив компьютер указанной задаче.

Теперь же попросите его исполнить инструкцию. Для этого вам уже не нужен **def**. Просто пишите само имя функции и загадывайте в скобках число, для которого хотите получить таблицу умножения! Готовы увидеть свое первое творение в действии?

Теперь точно получится, смотрите:
"""

multiplication_table(7)

"""**Два важных момента: названия функций и отступы**

* Называйте функции так, чтобы каждый мог понять по их имени, какую задачу они выполняют. Ведь вы будете писать функции не только для собственного развлечения, но и для других людей. Позаботьтесь о них, это несложно;
* Отступы! Обратите внимание на те строки, которые составляют тело функции: они все содержат отступ от края по сравнению с первой строкой. Так компьютер понимает, что эти команды относятся к самой функции и спешит их выполнять, а без отступов – не будет! Отступы обычно расставляются автоматически, но при необходимости пользуйтесь клавишей «пробел» или Tab.

"""

# А вот пример другой функции compute_sum(), в переводе: "вычисли сумму"

def compute_sum(x, y, z):  # В скобках заданы имена x, y и z - новые названия для любых чисел
    result = x + y + z   # Указание эти три числа сложить и записать в переменную под именем result
    return result        # О команде return - чуть подробнее ниже

"""Как и в примере выше, помните, что в скобках после имени функции вы можете указать все, что захотите. Можете придумать любые имена и туда их записать (все указанные в скобках объекты - называются **параметрами функции**).

Переменные **x, y, z** могут содержать те числа, которые вам нужны, когда вы будете использовать функцию. Они нужны под именами `x, y, z` только лишь для инструкции внутри самой (в теле) функции, чтобы компьютер в будущем знал, что ему с ними делать.

Что касается имени **result** – ничего страшного, что оно было и в предыдущей функции. До тех пор, пока имена используются внутри функций, они не перепутаются в ваших командах вне функций. Все будет хорошо, главное вам самим не запутаться в именах.

<h2>Команда return</h2>

И последнее здесь – команда **return**, которая переводится как «вернуть». Что она и делает – возвращает вам результат работы функции, когда компьютер уже вычислил сумму. Или может вернуть что-то другое, смотря что вы укажете в функции. Часто функции именно этой командой и завершают, но не всегда. Вы сами - творец своих функций.

Опробуйте работу новой функции:

"""

compute_sum(3, 4, 5)

"""<hr><strong>
Интересный факт о функциях: их можно помещать одна в другую. Или вызвать одну функцию из другой.
</strong>
<hr>

Например, в языке **Python** есть функция `max()` – нахождение максимального элемента последовательности.

Мастер-класс «встройте функцию в функцию, плюс добавьте задачу в довесок»:

"""

# Новое имя для новой функции: sum_max - сумма и максимум (от чисел в скобках)
def sum_max(x, y, z):
    # А здесь - вызов предыщуей функции! Ее результат записывается в новую переменную new_sum
    new_sum = compute_sum(x, y, z)
    # Упомянутая выше встроенная функция max() найдёт максимальное из трёх чисел и запишет результат в переменную maximum
    maximum = max(x, y, z)
    # В конце - указание вернуть оба результата командой return
    return new_sum, maximum

"""Убедитесь, что все сработало верно:

"""

sum_max(3, 5, 7)

"""И, наконец, пик мастерства для первого занятия – научите компьютер выдавать аж три результата из ***одной*** функции! Чтобы это сделать, нужно лишь немного обновить код:"""

# Новое имя - новая функция: sum_max_mean(), где mean - среднее значение от чисел в скобках
def sum_max_mean(x, y, z):
    # Начало такое же, как и в предыдущей функции sum_max()
    new_sum = compute_sum(x, y, z)
    # Всё пока без изменений
    maximum = max(x, y, z)
    # А вот и апгрейд - в переменной new_mean сохранится сумма чисел, деленная на три (среднее арифметическое трех чисел)
    new_mean = new_sum / 3
    # Указание компьютеру: "верни нам три вычисленных значения!"
    return new_sum, maximum, new_mean

"""Проверьте, работает ли? Вот и все."""

sum_max_mean(3, 5, 7)

"""Представьте, что вы с новыми знаниями теперь стали математиком, и напишите функцию, которая ищет и площадь, и периметр прямоугольника сразу! Площадь назовите **area**, а периметр – **perimeter**."""

def area_perimeter():

"""В определении функции в скобках можно указать и сами значения (так сказать, по умолчанию), для таких параметров указание значений при вызове функции станет необязательным.

Например, можно в скобках указать a=2 и b=4:
"""

def area_perimeter(a=2, b=4):

"""В завершение дополните код функции содержанием. Вспомните уроки математики четвертого-пятого класса! Как вычислить площадь прямоугольника и его периметр?"""

# Объявление функции вычисления площади и периметра
def area_perimeter(a=2, b=4):
    # Здесь в переменной s сохранится результат расчета площади по формуле: длины сторон перемножаются
    s = a * b
    # Вычисление периметра: удвоенная сумма сторон прямоугольника
    p = 2 * (a + b)
    # Наконец, необходимо вернуть полученные результаты
    return s, p

"""Вы задали в определении функции значения обоих параметров по умолчанию; теперь при вызове функции в скобках можно ничего и не указывать. Смотрите:"""

area_perimeter()

"""Но можно указать один или оба параметра явно, в таком случае явно заданное значение замещает значение по умолчанию:"""

area_perimeter(5)

area_perimeter(5, 8)

"""**Работает!**

На этом вы завершаете первое занятие! Дальше вас ждет еще множество новой и интересной информации. Верим в успех и прикладываем максимум усилий! :)

# Подведем итоги

* Язык программирования **Python** имеет свой **синтаксис** - набор правил, позволяющий давать компьютеру определенные инструкции;
* **Python** располагает арсеналом **встроенных функций**, например, `print()`, `input()`, `range()`;
* Для разных ситуаций пригодятся различные **типы данных**;
* **Условные операторы** позволяют выполнять часть кода при условии истинности заданных выражений;
* **Циклы** облегчают решение задач с повторениями;
* **Функции Python** пишете вы, главное – правильно все оформить. Внутри функции вы указываете одно или ряд действий, которые далее будут выполняться в одну строку – просто вызовом функции!

Теперь вы полностью готовы к выполнению первого домашнего задания.
Но советуем вам прежде попробовать свои силы и порешать примеры из задачника


---

[УИИ **Задачник** к теме "Синтаксис Python"](https://colab.research.google.com/drive/1ZwgxxVOUn7WTYlOYyfV564_6_br2nlnu?usp=sharing)

---

[УИИ **Задачник 2** к теме "Синтаксис Python"](https://colab.research.google.com/drive/1Fc4JqOS_PpHktHmT36430N_mvW_90btu?usp=sharing)

**Содержание темы**

1. [Часть 1](https://colab.research.google.com/drive/1KwsknDYT-51RKcAZgCaVV-LqsjJN7xQE?usp=sharing)

2. Часть 2
"""