# -*- coding: utf-8 -*-
"""Занятие 3.  Pandas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ckioj42mdQwIitDleO914dMCc2SHHvzG

"""

from google.colab import drive
drive.mount('/content/drive')

"""

---




 -  <a href="http://pandas.pydata.org/">Pandas</a> - библиотека для обработки и анализа данных. Предназначена для данных разной природы - матричных, панельных данных, временных рядов. Претендует на звание самого мощного и гибкого средства для анализа данных с открытым исходным кодом."""

import pandas as pd

"""В пандас есть две структуры данных:
- Series: одномерный массив с именованными индексами (чаще всего, данные одного типа)
- DataFrame: двухмерный массив, имеет табличную структуру, легко изменяется по размерам, может содержать в себе данные разных типов

Оба типа можно создавать вручную с помощью функций из самой библиотеки:
- pandas.Series(data=None, index=None, dtype=None)
- pandas.DataFrame(data=None, index=None, columns=None, dtype=None)

- **data** - данные, которые надо записать в структуру
- **index** - индексы строк
- **columns** - названия столбцов
- **dtype** - тип данных

Кроме data, остальные параметры опциональны

<body>
    <div class="container">
        <div>
            <h2>Series</h2>
            <table>
                <tr>
                    <th></th>
                    <th>Марка машины</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>Toyota</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>Honda</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Ford</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Chevrolet</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>Volkswagen</td>
                </tr>
            </table>
        </div>
        <div>
            <h2>DataFrame</h2>
            <table>
                <tr>
                    <th></th>
                    <th>марка машины</th>
                    <th>год выпуска</th>
                    <th>цена</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>Toyota</td>
                    <td>2022</td>
                    <td>25120.60</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>Honda</td>
                    <td>2021</td>
                    <td>22536.90</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Ford</td>
                    <td>2020</td>
                    <td>15305.10</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Chevrolet</td>
                    <td>2022</td>
                    <td>21733.50</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>Volkswagen</td>
                    <td>2021</td>
                    <td>45345.88</td>
                </tr>
            </table>
        </div>
    </div>
</body>

## ***Создание Series (одномерного массива)***

---

|  | Марка машины |
|-------|--------------|
|   0   |    Toyota    |
|   1   |     Honda    |
|   2   |     Ford     |
|   3   |  Chevrolet   |
|   4   |  Volkswagen  |
"""

car_prices = pd.Series({
    'Toyota': 25000,
    'Honda': 22000,
    'Ford': 23000,
    'Chevrolet': 21000,
    'Volkswagen': 27000
})

car_prices2 = pd.Series({
    1:'Toyota',
    2:'Honda',
    3:'Ford',
    4:'Chevrolet',
    5:'Volkswagen',
})


# Выводим таблицу Series
print(car_prices, end='\n\n')
print(car_prices2)

car_prices





"""## ***Создание DataFrame (Таблицы)***

---
|  | марка машины  | год выпуска |    цена  |
|----|-------------|-------------|----------|
| 0 |    Toyota    |    2022     |  25 000  |
| 1 |     Honda    |    2021     |  22 000  |
| 2 |     Ford     |    2020     |  15 000  |
| 3 |  Chevrolet   |    2022     |  21 000  |
| 4 |  Volkswagen  |    2021     |  45 000  |

>**1 Вариант**
"""

# Создаем исходную таблицу DataFrame
data = {
    'марка машины': ['Toyota', 'Honda', 'Ford', 'Chevrolet', 'Volkswagen'],
    'год выпуска': [2022, 2021, 2020, 2022, 2021],
    'цена': [25120.60, 22536.90, 15305.10, 21733.50, 45345.88]
}

df = pd.DataFrame(data)

display(df)
display(df)



df



"""#### **Типы данных**


---



---



- object - строковый тип данных или смешанный тескт/числов
- int64 - целочисленный тип, занимает 64 бита
- float64 - тип с плавающей точкой (вещественные числа), занимает 64 бита
- bool - логический тип данных для хранения значений True/False
- datetime64 - тип для хранения дат и времени
- timedelta64 - разница между датами
- category - тип для категориальных данных (ограниченный набор значений)

---


"""

display(df)
print(df.dtypes)
df.dtypes

"""> **2 Вариант**"""

columns = ['марка машины', 'год выпуска', 'цена']

data = [['Toyota',         '2022',        '25000'],
        ['Honda',          '2021',        '22000'],
        ['Ford',           '2020',        '23000'],
        ['Chevrolet',      '2022',        '21000'],
        ['Volkswagen',     '2021',        '27000']]

df2 = pd.DataFrame(data, columns=columns)

display(df2)

"""> Зададим индексы"""

columns = ['марка машины', 'год выпуска', 'цена']

data = [['Toyota', '2022', '25000'],
        ['Honda', '2021', '22000'],
        ['Ford', '2020', '23000'],
        ['Chevrolet', '2022', '21000'],
        ['Volkswagen', '2021', '27000']]

index = [100, 200, 300, 400, 500] # должны быть уникальными !!!

df2 = pd.DataFrame(data=data, index=index, columns=columns, dtype=object)

# Выводим таблицу
display(df2)
print(df2.dtypes)

"""> **3 Вариант**"""

text = '''
      марка машины, год выпуска, цена
      Toyota, 2022, 35 000
      Honda, 1987, 1 500
      Ford, 2005, 6 000
      Volkswagen, 2023, 40000
'''.strip()

with open('car.csv', 'w') as f:
  f.write(text)


df2 = pd.read_csv('/content/car.csv')

display(df2)

"""#### `delimiter=','` (разделитель)"""

print(1,2, sep=' ')

text = '''
      марка машины; год выпуска; цена
      Toyota; 2022; 35 000
      Honda; 1987; 1 500
      Ford; 2005; 6 000
      Volkswagen; 2023; 40000
'''.strip()

with open('car.csv', 'w') as f:
  f.write(text)


df2 = pd.read_csv('car.csv')
df3 = pd.read_csv('car.csv', delimiter=';')

display(df2)
print(end='\n\n')
display(df3)

display(df3)

"""#### `encoding` (кодировка)"""

text = '''
      марка машины; год выпуска; цена
      Toyota; 2022; 35 000
      Honda; 1987; 1 500
      Ford; 2005; 6 000
      Volkswagen; 2023; 40000
'''.strip()

with open('car.csv', 'w', encoding='cp1251') as f:
  f.write(text)


df4 = pd.read_csv('car.csv', delimiter=';', encoding='cp1251')

display(df4)

"""## ***Загрузка таблицы***
База вин = https://drive.google.com/file/d/1I0IrgrlR-Phv1sQZHOfr1ld866yMTahE/view

#### 1 способ загрузки таблицы
"""

import gdown

path_download = 'https://drive.google.com/uc?id=1I0IrgrlR-Phv1sQZHOfr1ld866yMTahE'

gdown.download(path_download, None, quiet=False)

# Commented out IPython magic to ensure Python compatibility.
# %cat wine_base.csv

#*** /content/wine_base.csv
## df = pd.read_csv('/content/wine_base.csv')
df.head(12)

"""#### 2 способ загрузки таблицы"""

path_download

df2 = pd.read_csv(path_download)
df2

"""Функции вида `pd.read_формат()` и `pd.to_формат()`
считывают и записывают данные соответственно.

Cчитайте данные в формате **csv** (***comma separated value/значения, разделённые запятыми***) функцией <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html#pandas.read_csv"> `pd.read_csv()`</a>.

Список самых важных аргументов:
 - **filepath_or_buffer** - текстовая строка с названием (адресом) файла;
 - **sep** - символ, которым отделены элементы датафрейма в файле (по умолчанию ",");
 - **header** - номер строки, в которой в файле указаны названия столбцов (**None**, если нет);
 - **names** - список с названиями столбцов;
 - **index_col** - столбец, из которого надо взять названия индексов
 - **usecols** - список столбцов для чтения из файла
"""

df = pd.read_csv('/content/wine_base.csv', index_col=0)
df

df.to_

pd.read_? # читаем
df.to_? # сохраняем

"""### ***Переименование названия столбцов*** (parameter = names)"""

new_names = ['страна', 'описание', 'наименование', 'баллы', 'цена', 'провинция', 'регион_1', 'регион_2', 'сорт', 'винодельня']

df_rus = pd.read_csv('wine_base.csv', names=new_names, index_col=0, header=1)
df_rus.head()

"""### ***Выбираем столбцы для загрузки*** (parameter = usecols)"""

data3 = pd.read_csv('wine_base.csv', usecols=['country', 'points', 'price'])
data3.tail(3)

"""### ***Задать кол-во столбцов и строк при выводе***"""

MaxDF = pd.read_csv('/content/sample_data/mnist_test.csv')
MaxDF

MaxDF[:100]

pd.set_option("display.max_columns", 100)
pd.set_option("display.max_rows", 500)

MaxDF = pd.read_csv('/content/sample_data/mnist_test.csv')
MaxDF

MaxDF[:500]

"""## ***Удаление***

---

В Pandas есть несколько способов удалить данные из DataFrame:

***Удалить строки:***
- data.drop(index) - удалить строки с указанными индексами
- data.drop(labels, axis=0) - удалить строки по значениям в выбранном столбце

***Удалить столбцы:***
- data.drop(columns) - удалить столбцы с указанными именами
- data.drop(labels, axis=1) - удалить столбцы по значениям в выбранной строке

***Удалить duplicates:***
- data.drop_duplicates() - удалить дубликаты строк

***Удалить NaN:***
- data.dropna() - удалить строки/столбцы с NaN значениями

```python
# Удаляем только строки с NaN значениями в столбце 'A'
df = df.dropna(subset=['A'])

# Удаляем строку с индексом 3 (где есть NaN)
df = df.dropna(axis=0, index=[3])
```
---
"""

df_rus.head(1)

# Удалим 2 столбца
df_rus.drop(columns=['описание', 'наименование'], inplace=True)

df_rus.head(2)

# Удалим 1 строку
df_rus.drop(2, inplace=True)

df_rus.head(2)

"""## ***Вставить данные***

---

---


***Добавить строку:***

- `df.loc[index] = [values]` - вставить строку по указанному индексу
- `df.append(other_df)` - конкатенировать два DataFrame

***Добавить столбец:***

- `df[column_name] = [values]` - вставить столбец по имени
- `df.insert(loc, column, values)` - вставить столбец по индексу

***Обновить ячейки:***

- `df.loc[row, column]` = value - присвоить значение по строке/столбцу
- `df.fillna(values)` - заполнить пропущенные ячейк

---



---

### ***Добавление столбцов и строк***
"""

# Создание списка с названием столбцов
columns = ['A', 'H', 'T', 'P']

# Создание списка со значениями ячеек
values = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12],
          [13, 14, 15, 16]]

# Создание таблицы из подготовленных данных и вывод на экран
df = pd.DataFrame(values, columns=columns)
df

"""#### Добавляем столбец"""

df['B'] = [1,1,1,1]
df

df.loc[:, 'B'] = [2, 2, 2, 2]
df

"""#### Добавляем строку к столбцу выше"""

df.loc[6] = [0,0,0,0,0]
df

"""#### Обновить значения в таблице"""

df.iloc[0, 1] = 200
df

df.loc[1, 'P'] = 99
df

"""### Удалить столбцы"""

df = df.drop(columns=['B'])
df

"""### Создание копии"""

data_backup = df.copy()

"""### Конкатенация 2 таблиц"""

# Создание списка с названием столбцов
columns = ['t', 'G', 'C']

# Создание списка со значениями ячеек
values = [[10, 20, 30],
          [50, 60, 70],
          [90, 100, 110],
          [130, 140, 150],
          [170, 180, 190]]

# Создание таблицы из подготовленных данных и вывод на экран
df_2 = pd.DataFrame(values, columns=columns)
display(df_2)
df_2.shape

df_2.shape



NEW_table = pd.concat([df, df_2], axis=1)
NEW_table

"""### ***Сортировка***

---

- **sort_values(axis=0)** сортирует по строкам (индексам оси 0**) >> default=0**
- **sort_values(axis=1)** сортирует по столбцам (индексам оси 1)

#### По столбцу
"""

df = df.sort_values('H', ascending=True) # ascending=False -> По убыванию
df

"""#### Сбросить индекс"""

df.index = [0,1,2,4]
df

df = df.reset_index(drop = True)
df

"""#### По строке"""

df = df.sort_values(by=0, axis=1, ascending=False) # by=4, axis=1 это строки, ascending=True по возрастанию
df

df = df.sort_values(by='P', axis=0, ascending=True) # by=4, axis=1 это столбцы, ascending=True по возрастанию
df

"""#### Перестановка по названию столбцов"""

aa = NEW_table[['A','H','C','t', 'G', 'P', 'T']]
aa

"""### Сохранить

> Сохранить локально
"""

df.to_csv('new_salen_train.csv', index=False)

""">Сохранить на Google диск"""

df.to_csv('/content/drive/My Drive/Базы/hh_parsed.csv', sep=';', encoding='cp1251')

"""##  ***Анализ данных***

---

"""

df_rus

"""Метод .`shape` возвращает размер датафрейма: количество строк и количество столбцов"""

df_rus.shape

"""Метод .size возвращает количество элементов в таблице:"""

df_rus.size

"""Иногда данные в некоторых ячейках таблицы пропущены. Это случается по разным причинам: возможно, данных по определенному элементу просто не было, а возможно, человек, который заполнял таблицу, случайно пропустил ячейку.

Метод `.count()` возвращает количество *непустых* записей в каждом столбце:

> Доля пропусков
"""

df_rus.count()

print(df.shape, end='\n\n')

df_rus.isna().sum() # / df_rus.shape[0]

# @title График data.count
Data = df_rus # @param {type:"raw"}
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('darkgrid')

plt.figure(figsize=(14,3))
counts = Data.count()
ax = counts.plot.bar()
ax.set_xlabel('Столбцы', c='r')
ax.set_ylabel('Кол-во записей', c='b')
ax.set_title('Количество непустых записей по столбцам', c='gray')


plt.show()

"""Используя метод .head(), вы можете применить метод .count() только к первым ста строкам таблицы:"""

df_rus.head(100).count() # 0 - 100

"""### ***Заполнение пустых значений***

Метод `.isna()` выдает таблицу того же размера, что и исходная, только заменяет значения в ячейках на **True** или **False**.
- **True** - если ячейка *пуста*
- **False** - если ячейка *заполнена*
"""

df_rus.isna().sum()

"""#### *В отдельном взятом стобце*"""

df_rus['цена'].fillna('Бесплатно !', inplace=True)

# df_rus['наименование'].fillna('Портвейн', inplace=True)

df_rus.count()

"""#### *Во всей таблице*"""

df_rus = df_rus.fillna('Ошибочка')

df_rus.count()

"""### ***Индексация***"""

df_rus[444:600].count() # 444 - 600

df_rus[:100:10]

df_rus[["баллы"]]

df_rus[["баллы", "цена"]][:10]

"""### ***Изменить тип данных***"""

maska = df_rus['цена']>1000
#df_rus[maska]
#maska

maska

df_rus.info()

df_rus.dropna(subset=["цена"], inplace=True)

df_rus["цена"] = df_rus["цена"].astype("int64")

"""#### *Замена значений*"""

df_rus['цена'] = df_rus['цена'].replace('Бесплатно !', 0)

df_rus["цена"] = df_rus["цена"].astype("int64")
df_rus.info()

df_rus.loc[maska, 'наименование']

maska = df_rus['цена'] > 1000
df_rus[maska]

"""### `.loc` // `.iloc`"""

df_rus.loc[:10, ['наименование', 'цена']]

df_rus.iloc[:10, 2:4]

# df_rus.loc[maska]
df_rus.loc[df_rus.регион_2.isna()==True]

"""#### *Посмотрим на скорость выполнения кода с помощью функций **Pandas** и циклов **Python**...* 🕔

❓❓ Зачем `.loc`, если есть `df[]` ❓❓
"""

#@title Делаем 3 000 000 строк
data = pd.read_csv('/content/sample_data/california_housing_test.csv')
df = [data] * 1000 # [] создает список, содержащий 100 копий объекта data, и таким образом, каждый элемент этого списка будет ссылаться на отдельный объект data, а не на один и тот же объект.

# конкатенация списка по строкам
df= pd.concat(df, axis=0)

# вывод результата
df.shape

# определение функции для преобразования housing_median_age
def transform_housing_median_age(data):
    # создание пустого списка для хранения новых значений
    new_values = []
    # проход по каждому значению в столбце housing_median_age
    for value in data.housing_median_age:
        # проверка условий и присвоение нового значения в соответствии с ними
        if value <= 15:
            new_value = 0
        elif 15 < value <= 30:
            new_value = 1
        else:
            new_value = 2
        # добавление нового значения в список
        new_values.append(new_value)
    # замена столбца housing_median_age на список новых значений
    data.housing_median_age = new_values
    # возврат преобразованного датафрейма
    return data

"""`%%time`, предоставляет данные о времени, затраченном на выполнение кода в этой ячейке. Эти данные включают в себя несколько значимых параметров:

1. `CPU times`: Этот блок показывает общее время, затраченное процессором на выполнение кода. В вашем примере это 1.57 секунды пользовательского времени и 102 миллисекунд системного времени. Пользовательское время отражает время, которое процессор затратил на выполнение команд, созданных вашим кодом, в то время как системное время представляет собой время, затраченное процессором на выполнение системных операций, связанных с вашим кодом.

2. `total`: Этот параметр представляет собой общее время, затраченное на выполнение кода. Он объединяет пользовательское и системное время.

3. `Wall time`: Этот параметр отображает реальное время, которое потребовалось для выполнения кода от начала до конца. Это может быть больше, чем сумма пользовательского и системного времени, так как оно учитывает внешние факторы, такие как задержки ввода-вывода или загрузка процессора другими задачами.


"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# df = transform_housing_median_age(df)

#%%time
df[df.housing_median_age <= 15] = 0
df[(df.housing_median_age > 15)&(df.housing_median_age <= 30)] = 1
df[df.housing_median_age > 30] = 2

# Commented out IPython magic to ensure Python compatibility.
# %%time
# df.loc[df.housing_median_age <= 15, 'housing_median_age'] = 0
# df.loc[(df.housing_median_age > 15)&(df.housing_median_age <= 30), 'housing_median_age'] = 1
# df.loc[df.housing_median_age > 30, 'housing_median_age'] = 2

"""|  Способ | Время |    
|---------|-------|
| Python  | 1680  |
| .loc    | 38.6  |
| Pandas  | 152   |
"""

#@title График
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style('darkgrid')

# Создание данных для сравнения
results = [152, 38.6, 1680] # в миллисекундах
labels = ["Pandas", "Pandas .loc", "Python циклы"]

plt.figure(figsize=(12,2)) # Изменим размер графика на горизонтальный
# Создание горизонтальной столбчатой диаграммы
plt.barh(labels, results, color=["g", "b", "m"]) # Используем функцию barh для создания горизонтальных столбцов

# Добавление подписей и заголовка
plt.xlabel("Время выполнения (мс)") # Перенесем подпись на ось X
plt.ylabel("Способ выполнения кода") # Перенесем подпись на ось Y
plt.title("Сравнение времени выполнения кода в Python")

# Показать график
plt.show()

df_rus.loc[maska]
df_rus.loc[df_rus.цена > 1000, ['наименование', 'баллы', 'цена']]

df_rus.loc[df_rus.наименование=='Портвейн', 'баллы'] = 100
df_rus.loc[df_rus.цена > 1000, ['наименование', 'баллы', 'цена']]

df_rus.loc[((df_rus.баллы == 100) & (df_rus.страна =='France')), ['баллы','страна', 'цена']]

"""### Описательные статистики

Теперь изучите методы для более подробного изучения данных датафрейма:

Метод `.describe()` возвращает таблицу с описательными статистиками числовых столбцов.  Рассмотрите каждый пункт::

- **count** - количество заполненных элементов
- **mean** - среднее значение по столбцу
- **std** - среднее квадратичное отклонение
- **min** - минимальное значение
- **процентили** - тут будет легче рассмотреть на примере. Представим шкалу на которой расположены все цены вин из таблицы. Обозначим на этой шкале 25-ю процентиль, 50-ю процентиль и 75-ю процентиль:


На этой шкале можно расположить все числовые данные, например цены. 25-ой процентилью будет 16\$. Это значит, что 25% вин дешевле, а остальные 75% дороже.


75-ая проццентиль будет равна 40\$. Соответственно, 75% вин имеют стоимость ниже 40\$, а остальные 25% - выше.

"""

df_rus.shape

df_rus.iloc[0]

df_rus.describe()

"""Параметр `include=['O']` метода `.describe()` выведет статистику для строковых данных:

- **count** - количество заполненных элементов
- **unique** - количество уникальных элементов
- **top** - самый распространенный элемент
- **freq** - сколько раз встречается самый распространенный элемент
"""

df_rus.describe(include=['O'])

"""Параметр `include=['O']` метода `.describe()` выведет статистику для строковых данных:

- **count** - количество заполненных элементов
- **unique** - количество уникальных элементов
- **top** - самый распространенный элемент
- **freq** - сколько раз встречается самый распространенный элемент
"""

df_rus.describe(include=['O'])

"""### ***Уникальные значения***"""

df_rus['наименование'].unique()

df_rus["страна"].unique()



df_rus['наименование'].nunique()